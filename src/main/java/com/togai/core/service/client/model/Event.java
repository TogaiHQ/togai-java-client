/*
 * Togai Apis
 * APIs for Togai App
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: engg@togai.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.togai.core.service.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.togai.core.service.client.model.EventAttribute;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.io.Serializable;

/**
 * Contents of the event
 */
@ApiModel(description = "Contents of the event")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class Event implements Serializable {
  private static final long serialVersionUID = 1L;

  public static final String SERIALIZED_NAME_EVENT_NAME = "eventName";
  @SerializedName(SERIALIZED_NAME_EVENT_NAME)
  private String eventName;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_EVENT_TIMESTAMP = "eventTimestamp";
  @SerializedName(SERIALIZED_NAME_EVENT_TIMESTAMP)
  private OffsetDateTime eventTimestamp;

  public static final String SERIALIZED_NAME_ACCOUNT_ID = "accountId";
  @SerializedName(SERIALIZED_NAME_ACCOUNT_ID)
  private String accountId;

  public static final String SERIALIZED_NAME_EVENT_ATTRIBUTES = "eventAttributes";
  @SerializedName(SERIALIZED_NAME_EVENT_ATTRIBUTES)
  private List<EventAttribute> eventAttributes = new ArrayList<>();

  public static final String SERIALIZED_NAME_DIMENSIONS = "dimensions";
  @SerializedName(SERIALIZED_NAME_DIMENSIONS)
  private Map<String, String> dimensions = new HashMap<>();

  public Event() {
  }

  public Event eventName(String eventName) {
    
    this.eventName = eventName;
    return this;
  }

   /**
   * Name of the event to be recorded.
   * @return eventName
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Name of the event to be recorded.")

  public String getEventName() {
    return eventName;
  }


  public void setEventName(String eventName) {
    this.eventName = eventName;
  }


  public Event id(String id) {
    
    this.id = id;
    return this;
  }

   /**
   * A unique value to identify the event instance. This unique value should be generated by the client and it acts as the **idempotency key**. Togai server will use this key to recognize subsequent retries of the same request and avoid metering multiple times for that same request. This id can be created in any format but we recommend using UUIDv4 to reduce collision occurance.    NOTE1: Expiry time for idempotency validation will be until the end of the billing cycle. Any request which comes after the billing cycle with the same id will be treated as new request and ingested for metering.   NOTE2: If the billing cycle is not configured for the idempotency validation will be until **10 days** of the event ingestion.
   * @return id
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "A unique value to identify the event instance. This unique value should be generated by the client and it acts as the **idempotency key**. Togai server will use this key to recognize subsequent retries of the same request and avoid metering multiple times for that same request. This id can be created in any format but we recommend using UUIDv4 to reduce collision occurance.    NOTE1: Expiry time for idempotency validation will be until the end of the billing cycle. Any request which comes after the billing cycle with the same id will be treated as new request and ingested for metering.   NOTE2: If the billing cycle is not configured for the idempotency validation will be until **10 days** of the event ingestion.")

  public String getId() {
    return id;
  }


  public void setId(String id) {
    this.id = id;
  }


  public Event eventTimestamp(OffsetDateTime eventTimestamp) {
    
    this.eventTimestamp = eventTimestamp;
    return this;
  }

   /**
   * Source time stamp of the event. This timestamp must be in ISO 8601 format.
   * @return eventTimestamp
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Source time stamp of the event. This timestamp must be in ISO 8601 format.")

  public OffsetDateTime getEventTimestamp() {
    return eventTimestamp;
  }


  public void setEventTimestamp(OffsetDateTime eventTimestamp) {
    this.eventTimestamp = eventTimestamp;
  }


  public Event accountId(String accountId) {
    
    this.accountId = accountId;
    return this;
  }

   /**
   * Get accountId
   * @return accountId
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")

  public String getAccountId() {
    return accountId;
  }


  public void setAccountId(String accountId) {
    this.accountId = accountId;
  }


  public Event eventAttributes(List<EventAttribute> eventAttributes) {
    
    this.eventAttributes = eventAttributes;
    return this;
  }

  public Event addEventAttributesItem(EventAttribute eventAttributesItem) {
    this.eventAttributes.add(eventAttributesItem);
    return this;
  }

   /**
   * Get eventAttributes
   * @return eventAttributes
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")

  public List<EventAttribute> getEventAttributes() {
    return eventAttributes;
  }


  public void setEventAttributes(List<EventAttribute> eventAttributes) {
    this.eventAttributes = eventAttributes;
  }


  public Event dimensions(Map<String, String> dimensions) {
    
    this.dimensions = dimensions;
    return this;
  }

  public Event putDimensionsItem(String key, String dimensionsItem) {
    this.dimensions.put(key, dimensionsItem);
    return this;
  }

   /**
   * Dimensions are tags/labels associated with the events. This dimensions can be used to configure billing, for queries, analytics and reports.
   * @return dimensions
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Dimensions are tags/labels associated with the events. This dimensions can be used to configure billing, for queries, analytics and reports.")

  public Map<String, String> getDimensions() {
    return dimensions;
  }


  public void setDimensions(Map<String, String> dimensions) {
    this.dimensions = dimensions;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Event event = (Event) o;
    return Objects.equals(this.eventName, event.eventName) &&
        Objects.equals(this.id, event.id) &&
        Objects.equals(this.eventTimestamp, event.eventTimestamp) &&
        Objects.equals(this.accountId, event.accountId) &&
        Objects.equals(this.eventAttributes, event.eventAttributes) &&
        Objects.equals(this.dimensions, event.dimensions);
  }

  @Override
  public int hashCode() {
    return Objects.hash(eventName, id, eventTimestamp, accountId, eventAttributes, dimensions);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Event {\n");
    sb.append("    eventName: ").append(toIndentedString(eventName)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    eventTimestamp: ").append(toIndentedString(eventTimestamp)).append("\n");
    sb.append("    accountId: ").append(toIndentedString(accountId)).append("\n");
    sb.append("    eventAttributes: ").append(toIndentedString(eventAttributes)).append("\n");
    sb.append("    dimensions: ").append(toIndentedString(dimensions)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

